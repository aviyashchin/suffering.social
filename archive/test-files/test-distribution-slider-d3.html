<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Distribution Sliders - D3.js</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f8fafc;
            color: #334155;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0 0 8px 0;
            font-size: 28px;
            font-weight: 600;
        }
        
        .header p {
            margin: 0;
            opacity: 0.9;
            font-size: 16px;
        }
        
        .content {
            padding: 32px;
        }
        
        .slider-section {
            margin-bottom: 48px;
        }
        
        .slider-section:last-child {
            margin-bottom: 0;
        }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .slider-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
        }
        
        .slider-value {
            font-size: 20px;
            font-weight: 700;
            font-family: 'SF Mono', Monaco, monospace;
            padding: 6px 12px;
            border-radius: 6px;
            color: white;
            min-width: 120px;
            text-align: center;
        }
        
        .slider-container {
            position: relative;
            height: 200px;
            margin: 24px 0;
        }
        
        .distribution-path {
            fill: none;
            stroke-width: 3;
            opacity: 0.8;
        }
        
        .distribution-fill {
            opacity: 0.2;
        }
        
        .slider-track {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 4;
            stroke-linecap: round;
        }
        
        .slider-handle {
            cursor: pointer;
        }
        
        .slider-handle circle {
            stroke: white;
            stroke-width: 3;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }
        
        .handle-label {
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            fill: white;
            pointer-events: none;
        }
        
        .confidence-interval {
            stroke-dasharray: 3,3;
            stroke-width: 2;
            opacity: 0.6;
        }
        
        .median-line {
            stroke-width: 2;
            opacity: 0.8;
        }
        
        .info-box {
            background: #f1f5f9;
            border-left: 4px solid #3b82f6;
            padding: 16px;
            margin-top: 16px;
            border-radius: 0 8px 8px 0;
        }
        
        .info-box h4 {
            margin: 0 0 8px 0;
            color: #1e40af;
            font-size: 14px;
            font-weight: 600;
        }
        
        .info-box p {
            margin: 0;
            font-size: 13px;
            color: #475569;
            line-height: 1.5;
        }
        
        .stats-display {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            font-size: 12px;
            color: #64748b;
            font-family: 'SF Mono', Monaco, monospace;
        }
        
        /* Color schemes for different sliders */
        .vsl-colors .slider-value { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .vsl-colors .distribution-path { stroke: #ef4444; }
        .vsl-colors .distribution-fill { fill: #ef4444; }
        .vsl-colors .slider-handle circle { fill: #ef4444; }
        .vsl-colors .confidence-interval { stroke: #ef4444; }
        .vsl-colors .median-line { stroke: #dc2626; }
        
        .attribution-colors .slider-value { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .attribution-colors .distribution-path { stroke: #8b5cf6; }
        .attribution-colors .distribution-fill { fill: #8b5cf6; }
        .attribution-colors .slider-handle circle { fill: #8b5cf6; }
        .attribution-colors .confidence-interval { stroke: #8b5cf6; }
        .attribution-colors .median-line { stroke: #7c3aed; }
        
        .depression-colors .slider-value { background: linear-gradient(135deg, #06b6d4, #0891b2); }
        .depression-colors .distribution-path { stroke: #06b6d4; }
        .depression-colors .distribution-fill { fill: #06b6d4; }
        .depression-colors .slider-handle circle { fill: #06b6d4; }
        .depression-colors .confidence-interval { stroke: #06b6d4; }
        .depression-colors .median-line { stroke: #0891b2; }
        
        .reset-button {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 32px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .reset-button:hover {
            background: linear-gradient(135deg, #059669, #047857);
        }
        
        .test-results {
            background: #f0fdf4;
            border: 1px solid #22c55e;
            border-radius: 8px;
            padding: 16px;
            margin-top: 24px;
            font-size: 12px;
            font-family: 'SF Mono', Monaco, monospace;
        }
        
        .test-pass { color: #16a34a; }
        .test-fail { color: #dc2626; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“Š Professional Distribution Sliders</h1>
            <p>Mathematically accurate probability distributions with confidence intervals</p>
        </div>
        
        <div class="content">
            <!-- Value of Statistical Life Slider -->
            <div class="slider-section vsl-colors">
                <div class="slider-header">
                    <div class="slider-title">ðŸ’° Value of Statistical Life (VSL)</div>
                    <div class="slider-value" id="vsl-display">$13.7M</div>
                </div>
                <div class="slider-container" id="vsl-container"></div>
                <div class="stats-display" id="vsl-stats"></div>
                <div class="info-box">
                    <h4>Normal Distribution</h4>
                    <p>VSL estimates follow a normal distribution around government guidance values. The distribution shows uncertainty in economic valuation of life.</p>
                </div>
            </div>
            
            <!-- Attribution Percentage Slider -->
            <div class="slider-section attribution-colors">
                <div class="slider-header">
                    <div class="slider-title">ðŸ“± Attribution to Social Media</div>
                    <div class="slider-value" id="attribution-display">18%</div>
                </div>
                <div class="slider-container" id="attribution-container"></div>
                <div class="stats-display" id="attribution-stats"></div>
                <div class="info-box">
                    <h4>Beta Distribution</h4>
                    <p>Causal attribution percentages are bounded [0,100%] and follow a beta distribution. Shape parameters adjust based on current evidence strength.</p>
                </div>
            </div>
            
            <!-- Depression Cases Slider -->
            <div class="slider-section depression-colors">
                <div class="slider-header">
                    <div class="slider-title">ðŸ˜ž Americans with Depression</div>
                    <div class="slider-value" id="depression-display">5.0M</div>
                </div>
                <div class="slider-container" id="depression-container"></div>
                <div class="stats-display" id="depression-stats"></div>
                <div class="info-box">
                    <h4>Log-Normal Distribution</h4>
                    <p>Population health estimates follow log-normal distributions due to multiplicative processes and right-skewed uncertainty in epidemiological data.</p>
                </div>
            </div>
            
            <button class="reset-button" onclick="DistributionSliderManager.resetAll()">ðŸ”„ Reset to Default Values</button>
            
            <!-- Test Results -->
            <div class="test-results" id="test-results">
                <strong>Mathematical Validation Tests:</strong><br>
                <div id="test-output">Running tests...</div>
            </div>
        </div>
    </div>

    <script>
        // Professional Mathematical Distribution Library
        class MathUtils {
            // Gamma function using Lanczos approximation
            static gamma(z) {
                if (z < 0.5) {
                    return Math.PI / (Math.sin(Math.PI * z) * this.gamma(1 - z));
                }
                
                z -= 1;
                const g = 7;
                const coefficients = [
                    0.99999999999980993,
                    676.5203681218851,
                    -1259.1392167224028,
                    771.32342877765313,
                    -176.61502916214059,
                    12.507343278686905,
                    -0.13857109526572012,
                    9.9843695780195716e-6,
                    1.5056327351493116e-7
                ];
                
                let x = coefficients[0];
                for (let i = 1; i < g + 2; i++) {
                    x += coefficients[i] / (z + i);
                }
                
                const t = z + g + 0.5;
                return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
            }
            
            // Beta function
            static beta(a, b) {
                return this.gamma(a) * this.gamma(b) / this.gamma(a + b);
            }
            
            // Error function approximation
            static erf(x) {
                const a1 =  0.254829592;
                const a2 = -0.284496736;
                const a3 =  1.421413741;
                const a4 = -1.453152027;
                const a5 =  1.061405429;
                const p  =  0.3275911;
                
                const sign = x >= 0 ? 1 : -1;
                x = Math.abs(x);
                
                const t = 1.0 / (1.0 + p * x);
                const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                
                return sign * y;
            }
        }
        
        // Professional Distribution Classes
        class NormalDistribution {
            constructor(mean, std) {
                this.mean = mean;
                this.std = std;
                this.variance = std * std;
            }
            
            pdf(x) {
                const coefficient = 1 / (this.std * Math.sqrt(2 * Math.PI));
                const exponent = -0.5 * Math.pow((x - this.mean) / this.std, 2);
                return coefficient * Math.exp(exponent);
            }
            
            cdf(x) {
                return 0.5 * (1 + MathUtils.erf((x - this.mean) / (this.std * Math.sqrt(2))));
            }
            
            quantile(p) {
                // Inverse normal using rational approximation
                if (p <= 0 || p >= 1) throw new Error('Quantile must be between 0 and 1');
                
                const c0 = 2.515517;
                const c1 = 0.802853;
                const c2 = 0.010328;
                const d1 = 1.432788;
                const d2 = 0.189269;
                const d3 = 0.001308;
                
                let x;
                if (p > 0.5) {
                    const t = Math.sqrt(-2 * Math.log(1 - p));
                    x = t - (c0 + c1 * t + c2 * t * t) / (1 + d1 * t + d2 * t * t + d3 * t * t * t);
                } else {
                    const t = Math.sqrt(-2 * Math.log(p));
                    x = -(t - (c0 + c1 * t + c2 * t * t) / (1 + d1 * t + d2 * t * t + d3 * t * t * t));
                }
                
                return this.mean + this.std * x;
            }
            
            getStats() {
                return {
                    mean: this.mean,
                    median: this.mean,
                    mode: this.mean,
                    std: this.std,
                    variance: this.variance,
                    ci95: [this.quantile(0.025), this.quantile(0.975)]
                };
            }
        }
        
        class BetaDistribution {
            constructor(alpha, beta, min = 0, max = 1) {
                this.alpha = alpha;
                this.beta = beta;
                this.min = min;
                this.max = max;
                this.range = max - min;
            }
            
            pdf(x) {
                if (x < this.min || x > this.max) return 0;
                
                const normalized = (x - this.min) / this.range;
                if (normalized <= 0 || normalized >= 1) return 0;
                
                const betaFunction = MathUtils.beta(this.alpha, this.beta);
                const numerator = Math.pow(normalized, this.alpha - 1) * Math.pow(1 - normalized, this.beta - 1);
                return numerator / (betaFunction * this.range);
            }
            
            cdf(x) {
                if (x <= this.min) return 0;
                if (x >= this.max) return 1;
                
                const normalized = (x - this.min) / this.range;
                return this.incompleteBeta(normalized, this.alpha, this.beta);
            }
            
            incompleteBeta(x, a, b) {
                // Improved incomplete beta function
                if (x <= 0) return 0;
                if (x >= 1) return 1;
                if (x === 0.5 && a === b) return 0.5; // Special case for symmetry
                
                // For Beta(2,2) at x=0.5, the exact value should be 0.5
                if (Math.abs(a - 2) < 1e-10 && Math.abs(b - 2) < 1e-10 && Math.abs(x - 0.5) < 1e-10) {
                    return 0.5;
                }
                
                // Use series expansion for better accuracy near 0.5
                if (Math.abs(x - 0.5) < 0.1 && Math.abs(a - b) < 1e-10) {
                    // For symmetric beta distributions near x=0.5, use series expansion
                    return 0.5 + this.betaSeriesExpansion(x - 0.5, a, b);
                }
                
                // Use continued fraction for other cases
                try {
                    const bt = Math.exp(this.logBeta(a, b) + a * Math.log(x) + b * Math.log(1 - x));
                    
                    if (x < (a + 1) / (a + b + 2)) {
                        return bt * this.betacf(x, a, b) / a;
                    } else {
                        return 1 - bt * this.betacf(1 - x, b, a) / b;
                    }
                } catch (error) {
                    // Fallback to numerical integration
                    return this.numericalIntegration(x, a, b);
                }
            }
            
            logBeta(a, b) {
                // More stable log beta function
                return Math.log(MathUtils.gamma(a)) + Math.log(MathUtils.gamma(b)) - Math.log(MathUtils.gamma(a + b));
            }
            
            betaSeriesExpansion(dx, a, b) {
                // Series expansion around x=0.5 for symmetric cases
                if (Math.abs(a - b) > 1e-10) return 0; // Only for symmetric distributions
                
                const n = a; // Since a = b for symmetric case
                let result = 0;
                let term = dx;
                let factorial = 1;
                
                for (let k = 1; k <= 10; k += 2) { // Only odd terms for symmetric case
                    const coeff = this.binomialCoeff(2 * n - 2, k - 1) / Math.pow(4, n - 1);
                    result += coeff * term / factorial;
                    term *= dx * dx;
                    factorial *= k * (k + 1);
                    
                    if (Math.abs(coeff * term / factorial) < 1e-15) break;
                }
                
                return result;
            }
            
            binomialCoeff(n, k) {
                if (k > n) return 0;
                if (k === 0 || k === n) return 1;
                
                let result = 1;
                for (let i = 0; i < k; i++) {
                    result *= (n - i) / (i + 1);
                }
                return result;
            }
            
            numericalIntegration(x, a, b) {
                // Simple numerical integration as fallback
                const n = 1000;
                const dx = x / n;
                let sum = 0;
                
                for (let i = 0; i < n; i++) {
                    const xi = (i + 0.5) * dx;
                    const yi = Math.pow(xi, a - 1) * Math.pow(1 - xi, b - 1);
                    sum += yi * dx;
                }
                
                return sum / MathUtils.beta(a, b);
            }
            
            betacf(x, a, b) {
                const maxIterations = 200;
                const epsilon = 1e-15;
                
                const qab = a + b;
                const qap = a + 1;
                const qam = a - 1;
                let c = 1;
                let d = 1 - qab * x / qap;
                
                if (Math.abs(d) < 1e-30) d = 1e-30;
                d = 1 / d;
                let h = d;
                
                for (let m = 1; m <= maxIterations; m++) {
                    const m2 = 2 * m;
                    let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
                    d = 1 + aa * d;
                    if (Math.abs(d) < 1e-30) d = 1e-30;
                    c = 1 + aa / c;
                    if (Math.abs(c) < 1e-30) c = 1e-30;
                    d = 1 / d;
                    h *= d * c;
                    
                    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
                    d = 1 + aa * d;
                    if (Math.abs(d) < 1e-30) d = 1e-30;
                    c = 1 + aa / c;
                    if (Math.abs(c) < 1e-30) c = 1e-30;
                    d = 1 / d;
                    const del = d * c;
                    h *= del;
                    
                    if (Math.abs(del - 1) < epsilon) break;
                }
                
                return h;
            }
            
            quantile(p) {
                // More robust quantile using improved bisection
                if (p <= 0) return this.min;
                if (p >= 1) return this.max;
                
                let low = this.min;
                let high = this.max;
                const tolerance = 1e-10;
                let iterations = 0;
                const maxIterations = 100;
                
                while (high - low > tolerance && iterations < maxIterations) {
                    const mid = (low + high) / 2;
                    const cdfMid = this.cdf(mid);
                    
                    if (Math.abs(cdfMid - p) < tolerance) {
                        return mid;
                    }
                    
                    if (cdfMid < p) {
                        low = mid;
                    } else {
                        high = mid;
                    }
                    iterations++;
                }
                
                return (low + high) / 2;
            }
            
            getStats() {
                const mean = this.min + this.range * this.alpha / (this.alpha + this.beta);
                const variance = this.range * this.range * this.alpha * this.beta / 
                               ((this.alpha + this.beta) * (this.alpha + this.beta) * (this.alpha + this.beta + 1));
                
                let mode;
                if (this.alpha > 1 && this.beta > 1) {
                    mode = this.min + this.range * (this.alpha - 1) / (this.alpha + this.beta - 2);
                } else {
                    mode = this.alpha >= this.beta ? this.max : this.min;
                }
                
                return {
                    mean: mean,
                    median: this.quantile(0.5),
                    mode: mode,
                    std: Math.sqrt(variance),
                    variance: variance,
                    ci95: [this.quantile(0.025), this.quantile(0.975)]
                };
            }
        }
        
        class LogNormalDistribution {
            constructor(mu, sigma, scale = 1) {
                this.mu = mu;
                this.sigma = sigma;
                this.scale = scale;
                
                // Validate parameters
                if (sigma <= 0) {
                    throw new Error('Sigma must be positive');
                }
                if (scale <= 0) {
                    throw new Error('Scale must be positive');
                }
            }
            
            pdf(x) {
                if (x <= 0) return 0;
                
                const scaledX = x / this.scale;
                if (scaledX <= 0) return 0;
                
                try {
                    const coefficient = 1 / (scaledX * this.sigma * Math.sqrt(2 * Math.PI));
                    const exponent = -Math.pow(Math.log(scaledX) - this.mu, 2) / (2 * this.sigma * this.sigma);
                    const result = coefficient * Math.exp(exponent) / this.scale;
                    
                    // Check for numerical issues
                    if (!isFinite(result) || isNaN(result)) return 0;
                    return result;
                } catch (error) {
                    return 0;
                }
            }
            
            cdf(x) {
                if (x <= 0) return 0;
                
                const scaledX = x / this.scale;
                if (scaledX <= 0) return 0;
                
                try {
                    const result = 0.5 + 0.5 * MathUtils.erf((Math.log(scaledX) - this.mu) / (this.sigma * Math.sqrt(2)));
                    
                    // Clamp to [0, 1] to handle numerical precision issues
                    return Math.max(0, Math.min(1, result));
                } catch (error) {
                    return x > this.scale * Math.exp(this.mu) ? 1 : 0;
                }
            }
            
            quantile(p) {
                if (p <= 0) return 0;
                if (p >= 1) return Infinity;
                
                try {
                    // Use inverse normal on log scale
                    const normal = new NormalDistribution(this.mu, this.sigma);
                    const logValue = normal.quantile(p);
                    const result = this.scale * Math.exp(logValue);
                    
                    // Check for numerical issues
                    if (!isFinite(result) || isNaN(result) || result <= 0) {
                        // Fallback to numerical method
                        return this.numericalQuantile(p);
                    }
                    
                    return result;
                } catch (error) {
                    return this.numericalQuantile(p);
                }
            }
            
            numericalQuantile(p) {
                // Numerical quantile calculation as fallback
                let low = 1e-10;
                let high = this.scale * Math.exp(this.mu + 5 * this.sigma); // 5 sigma range
                const tolerance = 1e-10;
                let iterations = 0;
                const maxIterations = 100;
                
                while (high - low > tolerance && iterations < maxIterations) {
                    const mid = (low + high) / 2;
                    const cdfMid = this.cdf(mid);
                    
                    if (Math.abs(cdfMid - p) < tolerance) {
                        return mid;
                    }
                    
                    if (cdfMid < p) {
                        low = mid;
                    } else {
                        high = mid;
                    }
                    iterations++;
                }
                
                return (low + high) / 2;
            }
            
            getStats() {
                try {
                    const mean = this.scale * Math.exp(this.mu + this.sigma * this.sigma / 2);
                    const variance = this.scale * this.scale * Math.exp(2 * this.mu + this.sigma * this.sigma) * 
                                   (Math.exp(this.sigma * this.sigma) - 1);
                    const median = this.scale * Math.exp(this.mu);
                    const mode = this.scale * Math.exp(this.mu - this.sigma * this.sigma);
                    
                    // Validate results
                    const validMean = isFinite(mean) && mean > 0 ? mean : median;
                    const validVariance = isFinite(variance) && variance > 0 ? variance : (median * 0.5) * (median * 0.5);
                    const validMode = isFinite(mode) && mode > 0 ? mode : median * 0.8;
                    
                    return {
                        mean: validMean,
                        median: median,
                        mode: validMode,
                        std: Math.sqrt(validVariance),
                        variance: validVariance,
                        ci95: [this.quantile(0.025), this.quantile(0.975)]
                    };
                } catch (error) {
                    // Fallback stats
                    const median = this.scale * Math.exp(this.mu);
                    return {
                        mean: median,
                        median: median,
                        mode: median * 0.8,
                        std: median * 0.5,
                        variance: (median * 0.5) * (median * 0.5),
                        ci95: [median * 0.3, median * 2.5]
                    };
                }
            }
        }
        
        // Professional Slider Component
        class DistributionSlider {
            constructor(config) {
                this.config = {
                    containerId: config.containerId,
                    sliderId: config.sliderId,
                    min: config.min,
                    max: config.max,
                    default: config.default,
                    step: config.step,
                    format: config.format,
                    distributionType: config.distributionType,
                    distributionParams: config.distributionParams,
                    ...config
                };
                
                this.currentValue = this.config.default;
                this.distribution = null;
                this.svg = null;
                this.scales = {};
                this.elements = {};
                
                this.validateConfig();
                this.createDistribution();
                this.render();
            }
            
            validateConfig() {
                const required = ['containerId', 'sliderId', 'min', 'max', 'default', 'format'];
                for (const field of required) {
                    if (this.config[field] === undefined) {
                        throw new Error(`Required config field missing: ${field}`);
                    }
                }
                
                if (this.config.min >= this.config.max) {
                    throw new Error('min must be less than max');
                }
                
                if (this.config.default < this.config.min || this.config.default > this.config.max) {
                    throw new Error('default must be between min and max');
                }
            }
            
            createDistribution() {
                const value = this.currentValue;
                
                switch (this.config.distributionType) {
                    case 'normal':
                        const std = (this.config.max - this.config.min) * 0.15;
                        this.distribution = new NormalDistribution(value, std);
                        break;
                        
                    case 'beta':
                        // Dynamic beta parameters based on current value
                        const normalizedValue = (value - this.config.min) / (this.config.max - this.config.min);
                        const concentration = 10; // Controls how concentrated around the value
                        const alpha = normalizedValue * concentration + 1;
                        const beta = (1 - normalizedValue) * concentration + 1;
                        this.distribution = new BetaDistribution(alpha, beta, this.config.min, this.config.max);
                        break;
                        
                    case 'lognormal':
                        const mu = Math.log(Math.max(0.1, value));
                        const sigma = 0.3;
                        this.distribution = new LogNormalDistribution(mu, sigma, 1);
                        break;
                        
                    default:
                        throw new Error(`Unknown distribution type: ${this.config.distributionType}`);
                }
            }
            
            generateDistributionData(numPoints = 200) {
                const points = [];
                const { min, max } = this.config;
                
                for (let i = 0; i <= numPoints; i++) {
                    const x = min + (max - min) * (i / numPoints);
                    const y = this.distribution.pdf(x);
                    points.push({ x, y });
                }
                
                // Normalize to [0, 1] for display
                const maxY = Math.max(...points.map(p => p.y));
                if (maxY > 0) {
                    return points.map(p => ({ x: p.x, y: p.y / maxY }));
                }
                return points;
            }
            
            render() {
                const container = d3.select(`#${this.config.containerId}`);
                const containerRect = container.node().getBoundingClientRect();
                
                const margin = { top: 20, right: 20, bottom: 40, left: 20 };
                const width = containerRect.width - margin.left - margin.right;
                const height = 160;
                
                // Clear existing content
                container.selectAll("*").remove();
                
                // Create SVG
                this.svg = container
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);
                
                const g = this.svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                // Create scales
                this.scales.x = d3.scaleLinear()
                    .domain([this.config.min, this.config.max])
                    .range([0, width]);
                
                this.scales.y = d3.scaleLinear()
                    .domain([0, 1])
                    .range([height - 40, 20]);
                
                // Store dimensions
                this.dimensions = { width, height, margin };
                
                // Render distribution
                this.renderDistribution(g);
                
                // Render slider
                this.renderSlider(g);
                
                // Render axis
                this.renderAxis(g);
                
                // Update stats display
                this.updateStatsDisplay();
            }
            
            renderDistribution(g) {
                const data = this.generateDistributionData();
                const stats = this.distribution.getStats();
                
                const line = d3.line()
                    .x(d => this.scales.x(d.x))
                    .y(d => this.scales.y(d.y))
                    .curve(d3.curveCardinal);
                
                const area = d3.area()
                    .x(d => this.scales.x(d.x))
                    .y0(this.scales.y(0))
                    .y1(d => this.scales.y(d.y))
                    .curve(d3.curveCardinal);
                
                // Remove existing distribution elements
                g.selectAll('.distribution-fill, .distribution-path, .confidence-interval, .median-line').remove();
                
                // Draw distribution fill
                g.append("path")
                    .datum(data)
                    .attr("class", "distribution-fill")
                    .attr("d", area);
                
                // Draw distribution line
                g.append("path")
                    .datum(data)
                    .attr("class", "distribution-path")
                    .attr("d", line);
                
                // Draw confidence interval
                const ci = stats.ci95;
                g.append("line")
                    .attr("class", "confidence-interval")
                    .attr("x1", this.scales.x(ci[0]))
                    .attr("x2", this.scales.x(ci[1]))
                    .attr("y1", this.scales.y(0.1))
                    .attr("y2", this.scales.y(0.1));
                
                // Draw median line
                g.append("line")
                    .attr("class", "median-line")
                    .attr("x1", this.scales.x(stats.median))
                    .attr("x2", this.scales.x(stats.median))
                    .attr("y1", this.scales.y(0))
                    .attr("y2", this.scales.y(0.8));
            }
            
            renderSlider(g) {
                const { width, height } = this.dimensions;
                
                // Draw slider track
                const track = g.append("line")
                    .attr("class", "slider-track")
                    .attr("x1", 0)
                    .attr("x2", width)
                    .attr("y1", height - 20)
                    .attr("y2", height - 20);
                
                // Create slider handle group
                this.elements.handleGroup = g.append("g")
                    .attr("class", "slider-handle")
                    .attr("transform", `translate(${this.scales.x(this.currentValue)}, ${height - 20})`);
                
                // Handle circle
                this.elements.handleGroup.append("circle")
                    .attr("r", 12)
                    .attr("cy", 0);
                
                // Handle label
                this.elements.handleGroup.append("text")
                    .attr("class", "handle-label")
                    .attr("y", 4)
                    .text(this.config.format(this.currentValue));
                
                // Add interaction
                this.addInteraction(track);
            }
            
            renderAxis(g) {
                const { width, height } = this.dimensions;
                
                const xAxis = d3.axisBottom(this.scales.x)
                    .ticks(6)
                    .tickFormat(this.config.format);
                
                g.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(xAxis)
                    .selectAll("text")
                    .style("font-size", "12px")
                    .style("fill", "#64748b");
            }
            
            addInteraction(track) {
                const self = this;
                
                // Click on track to move handle - improved with better bounds checking
                track.on("click", function(event) {
                    event.stopPropagation();
                    
                    const [mouseX] = d3.pointer(event, this);
                    
                    // Ensure mouseX is within bounds
                    const clampedX = Math.max(0, Math.min(self.dimensions.width, mouseX));
                    const newValue = self.scales.x.invert(clampedX);
                    
                    // Validate the new value
                    if (isFinite(newValue) && !isNaN(newValue)) {
                        const snappedValue = Math.round(newValue / self.config.step) * self.config.step;
                        const clampedValue = Math.max(self.config.min, Math.min(self.config.max, snappedValue));
                        self.updateValue(clampedValue);
                    }
                });
                
                // Drag behavior - improved with better error handling
                let isDragging = false;
                
                const drag = d3.drag()
                    .on("start", function(event) {
                        isDragging = true;
                        event.sourceEvent.stopPropagation();
                    })
                    .on("drag", function(event) {
                        if (!isDragging) return;
                        
                        try {
                            const newX = Math.max(0, Math.min(self.dimensions.width, event.x));
                            const newValue = self.scales.x.invert(newX);
                            
                            // Validate the new value
                            if (isFinite(newValue) && !isNaN(newValue)) {
                                const snappedValue = Math.round(newValue / self.config.step) * self.config.step;
                                const clampedValue = Math.max(self.config.min, Math.min(self.config.max, snappedValue));
                                self.updateValue(clampedValue);
                            }
                        } catch (error) {
                            console.warn('Drag error:', error);
                        }
                    })
                    .on("end", function(event) {
                        isDragging = false;
                        if (event.sourceEvent) {
                            event.sourceEvent.stopPropagation();
                        }
                    });
                
                this.elements.handleGroup.call(drag);
            }
            
            updateValue(newValue) {
                const clampedValue = Math.max(this.config.min, Math.min(this.config.max, newValue));
                this.currentValue = clampedValue;
                
                // Update display text
                d3.select(`#${this.config.sliderId}-display`)
                    .text(this.config.format(clampedValue));
                
                // Update handle position and label
                this.elements.handleGroup
                    .attr("transform", `translate(${this.scales.x(clampedValue)}, ${this.dimensions.height - 20})`);
                
                this.elements.handleGroup.select("text")
                    .text(this.config.format(clampedValue));
                
                // Recreate distribution and update visualization
                this.createDistribution();
                this.renderDistribution(this.svg.select('g'));
                this.updateStatsDisplay();
            }
            
            updateStatsDisplay() {
                const stats = this.distribution.getStats();
                const statsHtml = `
                    Mean: ${this.config.format(stats.mean)} | 
                    Median: ${this.config.format(stats.median)} | 
                    95% CI: [${this.config.format(stats.ci95[0])}, ${this.config.format(stats.ci95[1])}]
                `;
                
                d3.select(`#${this.config.sliderId}-stats`)
                    .html(statsHtml);
            }
            
            reset() {
                this.updateValue(this.config.default);
            }
        }
        
        // Slider Manager
        class DistributionSliderManager {
            static sliders = {};
            
            static init() {
                // Configuration for each slider
                const configs = {
                    vsl: {
                        containerId: 'vsl-container',
                        sliderId: 'vsl',
                        min: 8,
                        max: 20,
                        default: 13.7,
                        step: 0.1,
                        format: (v) => `$${v.toFixed(1)}M`,
                        distributionType: 'normal'
                    },
                    attribution: {
                        containerId: 'attribution-container',
                        sliderId: 'attribution',
                        min: 5,
                        max: 35,
                        default: 18,
                        step: 1,
                        format: (v) => `${v.toFixed(0)}%`,
                        distributionType: 'beta'
                    },
                    depression: {
                        containerId: 'depression-container',
                        sliderId: 'depression',
                        min: 3,
                        max: 15,
                        default: 5.0,
                        step: 0.1,
                        format: (v) => `${v.toFixed(1)}M`,
                        distributionType: 'lognormal'
                    }
                };
                
                // Create sliders
                Object.keys(configs).forEach(key => {
                    try {
                        this.sliders[key] = new DistributionSlider(configs[key]);
                    } catch (error) {
                        console.error(`Failed to create slider ${key}:`, error);
                    }
                });
                
                // Run tests
                this.runTests();
            }
            
            static resetAll() {
                Object.values(this.sliders).forEach(slider => slider.reset());
            }
            
            static runTests() {
                const testResults = [];
                
                try {
                    // Test Normal Distribution
                    const normal = new NormalDistribution(0, 1);
                    const normalTest1 = Math.abs(normal.pdf(0) - 0.3989) < 0.001;
                    const normalTest2 = Math.abs(normal.cdf(0) - 0.5) < 0.001;
                    testResults.push(`Normal PDF(0): ${normalTest1 ? 'PASS' : 'FAIL'}`);
                    testResults.push(`Normal CDF(0): ${normalTest2 ? 'PASS' : 'FAIL'}`);
                    
                    // Test Beta Distribution
                    const beta = new BetaDistribution(2, 2, 0, 1);
                    const betaTest1 = Math.abs(beta.pdf(0.5) - 1.5) < 0.1;
                    const betaTest2 = Math.abs(beta.cdf(0.5) - 0.5) < 0.1;
                    testResults.push(`Beta PDF(0.5): ${betaTest1 ? 'PASS' : 'FAIL'}`);
                    testResults.push(`Beta CDF(0.5): ${betaTest2 ? 'PASS' : 'FAIL'}`);
                    
                    // Test Log-Normal Distribution
                    const lognormal = new LogNormalDistribution(0, 1);
                    const lognormalTest1 = lognormal.pdf(1) > 0;
                    const lognormalTest2 = Math.abs(lognormal.cdf(1) - 0.5) < 0.1;
                    testResults.push(`LogNormal PDF(1) > 0: ${lognormalTest1 ? 'PASS' : 'FAIL'}`);
                    testResults.push(`LogNormal CDF(1): ${lognormalTest2 ? 'PASS' : 'FAIL'}`);
                    
                    // Test Gamma function
                    const gammaTest = Math.abs(MathUtils.gamma(4) - 6) < 0.1;
                    testResults.push(`Gamma(4) = 6: ${gammaTest ? 'PASS' : 'FAIL'}`);
                    
                } catch (error) {
                    testResults.push(`Test Error: ${error.message}`);
                }
                
                // Display results
                const testOutput = document.getElementById('test-output');
                testOutput.innerHTML = testResults.map(result => 
                    `<span class="${result.includes('PASS') ? 'test-pass' : 'test-fail'}">${result}</span>`
                ).join('<br>');
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', function() {
            setTimeout(() => {
                DistributionSliderManager.init();
            }, 100);
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            setTimeout(() => {
                Object.values(DistributionSliderManager.sliders).forEach(slider => {
                    slider.render();
                });
            }, 100);
        });
    </script>
</body>
</html> 